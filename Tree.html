<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>üéÑ Christmas Tree with dat.GUI</title>
  <style>
  /* CSS */
  body {
    background: #111;
    /* ·∫®n thanh cu·ªôn n·∫øu canvas tr√†n m√†n h√¨nh */
    margin: 0;
    overflow: hidden; 
  }
  canvas {
    display: block; /* Lo·∫°i b·ªè kho·∫£ng tr·∫Øng b√™n d∆∞·ªõi canvas */
    width: 100vw;
    height: 100vh;
  }
  
  /* Style cho ch·∫ø ƒë·ªô ghi h√¨nh */
  body.recording {
    pointer-events: none;
  }
  body.recording::before {
    content: 'üìπ recording‚Ä¶';
    position: fixed;
    z-index: 999;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    margin: auto;
    display: inline-block;
    width: 15ch;
    height: 2em;
    line-height: 2em;
    text-align: center;
    white-space: nowrap;
    color: white;
    background: rgba(0,0,0,.5);
    padding: 1em;
    border-radius: 50vh;
    font-size: 2vw; /* T√πy ch·ªânh k√≠ch th∆∞·ªõc font cho th√¥ng b√°o */
  }
  body.recording canvas {
    opacity: .66;
  }

  /* dat.GUI customisation */
  .dg li.title {
    font-weight: bold;
    font-size: 14px;
    line-height: 30px;
    height: 30px;
    margin-left: -7px;
  }
  /* BUG fix for function property name width */
  .dg .cr.function .property-name {
    width: 100%;
  }
  </style> 
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
  </head>
<body>
  <canvas id="canvas"></canvas>
  <script>
  // ======================================================================
  // üí° GIA L·∫¨P TH∆Ø VI·ªÜN CGL (Ch·ªâ ƒë·ªÉ m√£ ch·∫°y)
  // C√°c h√†m n√†y ƒë∆∞·ª£c vi·∫øt ƒë∆°n gi·∫£n ƒë·ªÉ thay th·∫ø cho CGL g·ªëc.
  // ======================================================================
  const CGL = {
    colorConvert: {
      // Chuy·ªÉn ƒë·ªïi HEX sang m·∫£ng [R, G, B]
      hexToRgb: hex => {
        const bigint = parseInt(hex.slice(1), 16);
        return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255];
      },
      // Chuy·ªÉn ƒë·ªïi [R, G, B] sang HEX
      rgbToHex: (r, g, b) => '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase(),
      // Tr·ªôn m√†u (linear interpolation)
      mixBlendColors: (color1, color2, weight) => {
        const rgb1 = CGL.colorConvert.hexToRgb(color1);
        const rgb2 = CGL.colorConvert.hexToRgb(color2);
        const r = Math.round(rgb1[0] * (1 - weight) + rgb2[0] * weight);
        const g = Math.round(rgb1[1] * (1 - weight) + rgb2[1] * weight);
        const b = Math.round(rgb1[2] * (1 - weight) + rgb2[2] * weight);
        return CGL.colorConvert.rgbToHex(r, g, b);
      },
      // Th√™m ƒë·ªô m·ªù (opacity) v√†o m√†u HEX
      opacity: (hex, alpha) => {
        const rgb = CGL.colorConvert.hexToRgb(hex);
        return `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${alpha})`;
      }
    },
    saveAs: {
      // L∆∞u d∆∞·ªõi d·∫°ng PNG
      PNG: (canvas, filename) => {
        const link = document.createElement('a');
        link.download = filename + '.png';
        canvas.toBlob(blob => {
          link.href = URL.createObjectURL(blob);
          link.click();
        }, 'image/png');
      },
      // Gi·∫£ l·∫≠p WEBM recorder (s·ª≠ d·ª•ng MediaRecorder API th·ª±c t·∫ø)
      WEBM: (canvas, filename) => {
        let recorder = null;
        let chunks = [];
        
        return {
          start: () => {
            const stream = canvas.captureStream(60); // 60 fps
            recorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
            recorder.ondataavailable = e => chunks.push(e.data);
            recorder.onstop = () => {
              const blob = new Blob(chunks, { type: 'video/webm' });
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              document.body.appendChild(a);
              a.style = 'display: none';
              a.href = url;
              a.download = filename + '.webm';
              a.click();
              window.URL.revokeObjectURL(url);
              chunks = [];
            };
            recorder.start();
            console.log("Video recording started...");
          },
          stop: () => {
            if (recorder && recorder.state !== 'inactive') {
              recorder.stop();
              console.log("Video recording stopped. Downloading...");
            }
          }
        };
      }
    }
  };


  // # Default state
  let settings = {
    background: '#111',
    rotationX: 30,
    treeShape: 't => t', // Linear shape by default
    'video length [s]': 10
  }
  let chains = [
    { bulbRadius: 2, bulbsCount: 100, endColor: "#FFC", glowOffset: 0, opacity: 1, startAngle: 0, startColor: "#FFC", turnsCount: 14},
    { bulbRadius: 50, bulbsCount: 20, endColor: "#0FF", glowOffset: 0, opacity: 0.3, startAngle: 120, startColor: "#FF0", turnsCount: 3},
    { bulbRadius: 12, bulbsCount: 50, endColor: "#FF0", glowOffset: 0, opacity: 0.68, startAngle: 240, startColor: "#0FF", turnsCount: -3}
  ];


  // # Global vars
  const pixelRatio = window.devicePixelRatio;
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  let gui = null;
  let guiFirstFolder = null;
  let guiLastFolder = null;
  let rotationZ = 0; // Rotation around the Z (vertical) axis


  // # Customisation via dat.GUI
  function getRandomChain() {
    return {
      bulbsCount: Math.round(Math.random() * (100 - 10) + 10),
      bulbRadius: Math.round(Math.random() * (20 - 1) + 1),
      glowOffset: Math.random() < 0.5 ? 0 : Math.round(Math.random() * (20 - 10) + 10),
      turnsCount: Math.round(Math.random() * (10 - 3) + 3) * (Math.random() < 0.5 ? -1 : 1),
      startAngle: Math.round(Math.random() * 360),
      startColor: CGL.colorConvert.rgbToHex(Math.random()*255, Math.random()*255, Math.random()*255),
      endColor: CGL.colorConvert.rgbToHex(Math.random()*255, Math.random()*255, Math.random()*255),
      opacity: Math.round(Math.random() * (100 - 60) + 60) / 100
    };
  }

  const guiMethods = {
    'ADD CHAIN': () => {
      chains.push(getRandomChain());
      updateDatGui();
      // M·ªü folder chain m·ªõi t·∫°o
      if (guiLastFolder) {
        guiLastFolder.open(); 
      }
    },
    'REMOVE CHAIN': null, // Bi·∫øn placeholder cho l·ª±a ch·ªçn
    removeChain: () => {
      const index = guiMethods['REMOVE CHAIN'];
      // Ki·ªÉm tra xem index c√≥ ph·∫£i l√† s·ªë h·ª£p l·ªá kh√¥ng
      if (typeof index === 'number' && !Number.isNaN(index) && index >= 0 && index < chains.length) {
        chains.splice(index, 1);
        guiMethods['REMOVE CHAIN'] = null;
        updateDatGui();
      }
    },
    'üì∑ Save as image': () => {
      CGL.saveAs.PNG(canvas, 'my-christmas-tree');
    },
    'üé• Save as video': () => {
      const recorder = CGL.saveAs.WEBM(canvas, 'my-christmas-tree');
      recorder.start();
      document.body.classList.add('recording');
      setTimeout(() => {
        recorder.stop();
        document.body.classList.remove('recording');
      }, settings['video length [s]'] * 1000);
    }
  };

  function updateDatGui() {
    if (gui) {
      gui.destroy();
    }
    gui = new dat.GUI();
    guiLastFolder = null;
    
    // Th√™m c√°c folder cho t·ª´ng chu·ªói ƒë√®n
    chains.forEach((chain, i) => {
      const guiChain = gui.addFolder('üéÑ Chain ' + (i+1));
      guiChain.add(chains[i], 'bulbsCount', 10, 500, 1).name('Bulb Count');
      guiChain.add(chains[i], 'bulbRadius', 1, 100, 1).name('Bulb Radius');
      guiChain.add(chains[i], 'glowOffset', 0, 100, 1).name('Glow Offset');
      guiChain.add(chains[i], 'turnsCount', -50, 50, 1).name('Turns');
      guiChain.add(chains[i], 'startAngle', 0, 360, 1).name('Start Angle');
      guiChain.addColor(chains[i], 'startColor').name('Start Color');
      guiChain.addColor(chains[i], 'endColor').name('End Color');
      guiChain.add(chains[i], 'opacity', 0, 1, .01).name('Opacity');
      if (i === 0) {
        guiFirstFolder = guiChain;
      }
      if (i === chains.length - 1) {
        guiLastFolder = guiChain;
      }
    });
    
    // Chu·∫©n b·ªã danh s√°ch cho t√πy ch·ªçn 'REMOVE CHAIN'
    let folders = {};
    chains.forEach((chain, i) => folders[`Chain ${i+1}`] = i);

    // C√°c h√†m easing cho h√¨nh d·∫°ng c√¢y
    const shapes = {
      linear: 't => t',
      easeInQuad: 't => t*t',
      easeOutQuad: 't => t*(2-t)',
      easeInOutQuad: 't => (t<.5 ? 2*t*t : -1+(4-2*t)*t)',
      easeInCubic: 't => t*t*t',
      easeOutCubic: 't => (t-1)**3 + 1',
    };

    // Folder Options
    const guiOptions = gui.addFolder('‚öôÔ∏è Options');
    guiOptions.addColor(settings, 'background').name('Background Color');
    guiOptions.add(settings, 'rotationX', 0, 75, 1).name('Tilt Angle (X)');
    guiOptions.add(settings, 'treeShape', shapes).name('Tree Shape Easing');
    guiOptions.add(guiMethods, 'ADD CHAIN');
    // Th√™m control ƒë·ªÉ ch·ªçn v√† x√≥a chu·ªói
    guiOptions.add(guiMethods, 'REMOVE CHAIN', folders).name('Select Chain to Remove').onChange(guiMethods.removeChain);
    guiOptions.open();

    // Folder Export
    const guiExport = gui.addFolder('üíæ Export');
    guiExport.add(guiMethods, 'üì∑ Save as image');
    guiExport.add(guiMethods, 'üé• Save as video');
    guiExport.add(settings, 'video length [s]', 1, 60, 1).name('Video Length (s)');

    return gui;
  }

  // Kh·ªüi t·∫°o dat.GUI l·∫ßn ƒë·∫ßu
  updateDatGui();
  if (guiFirstFolder) {
    guiFirstFolder.open();
  }


  // # Rendering c·ªßa c√¢y
  let treeHeight, baseRadius, baseCenter, tiltAngle;
  
  function updateScene() {
    let {innerWidth: canvasWidth, innerHeight: canvasHeight} = window;
    
    // C·∫≠p nh·∫≠t k√≠ch th∆∞·ªõc canvas
    canvas.width  = canvasWidth * pixelRatio;
    canvas.height = canvasHeight * pixelRatio;
    ctx.scale(pixelRatio, pixelRatio);
    
    // T√≠nh to√°n c√°c tham s·ªë h√¨nh h·ªçc
    tiltAngle = settings.rotationX / 180 * Math.PI;
    treeHeight = Math.min(canvasWidth, canvasHeight) * .8;
    baseRadius = treeHeight * .3;
    
    // T√≠nh to√°n v·ªã tr√≠ t√¢m ƒë√°y c√¢y (c√≥ t√≠nh ƒë·∫øn g√≥c nghi√™ng)
    baseCenter = {
      x: canvasWidth/2, 
      // D·ªãch chuy·ªÉn y ƒë·ªÉ g·ªëc c√¢y n·∫±m ·ªü trung t√¢m (khi tilt=0) 
      // v√† ƒëi·ªÅu ch·ªânh theo g√≥c nghi√™ng
      y: canvasHeight/2 + treeHeight/2 * Math.cos(tiltAngle) - baseRadius/2 * Math.sin(tiltAngle)
    };
    
    // X√≥a v√† v·∫Ω n·ªÅn
    ctx.fillStyle = settings.background;
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);
    ctx.lineWidth = 1.1;  
  }

  function renderChain(props) {
    // eval ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ chuy·ªÉn chu·ªói easing th√†nh h√†m
    const easing = eval(`(${settings.treeShape})`); 

    for (let i = 0; i < props.bulbsCount; i++) {
      let progress = i / (props.bulbsCount - 1);
      // ƒêi·ªÅu ch·ªânh kho·∫£ng c√°ch gi·ªØa c√°c b√≥ng ƒë√®n (kh√¥ng ph·∫£i linear)
      progress = Math.pow((progress), Math.sqrt(progress) + 1); 

      // T√≠nh to√°n g√≥c v√† b√°n k√≠nh
      const sectionProgress = easing(progress); // √Åp d·ª•ng h√†m easing cho h√¨nh d·∫°ng c√¢y
      const sectionRadius = baseRadius * (1 - sectionProgress);
      const turnProgress = (progress * props.turnsCount) % 1;
      const sectionAngle = ((turnProgress * 360 + props.startAngle + rotationZ) / 180 * Math.PI) % (Math.PI*2);
      
      // ƒê·ªô m·ªù d·ª±a tr√™n g√≥c nh√¨n (l√†m b√≥ng ƒë√®n ·ªü ph√≠a sau m·ªù h∆°n)
      const opacityFactor = Math.min(1, Math.max(0, Math.cos(sectionAngle)) + .2);
      
      // T·ªça ƒë·ªô X
      const X = baseCenter.x + (Math.sin(sectionAngle) * sectionRadius);
      
      // T·ªça ƒë·ªô Y (chi·ªÅu cao)
      // treeHeight * sin(90-tiltAngle) l√† chi·ªÅu cao h√¨nh h·ªçc sau khi nghi√™ng
      const Y_projection = progress * treeHeight * Math.sin((90 - settings.rotationX) / 180 * Math.PI);
      // Hi·ªáu ·ª©ng 3D c·ªßa b√°n k√≠nh (cos(sectionAngle) d·ªãch chuy·ªÉn theo Z)
      const Y_depth_shift = sectionRadius * Math.sin(tiltAngle) * Math.cos(sectionAngle);

      const Y = baseCenter.y - Y_projection + Y_depth_shift;
      
      const bulbRadius = props.bulbRadius * treeHeight/1000;
      const glowRadius = (props.bulbRadius + props.glowOffset) * treeHeight/1000;
      
      // M√†u s·∫Øc ƒë∆∞·ª£c tr·ªôn
      const baseColor = CGL.colorConvert.mixBlendColors(props.startColor, props.endColor, progress);
      const currentColor = CGL.colorConvert.opacity(baseColor, opacityFactor);
      
      // ƒê·∫∑t ƒë·ªô m·ªù chung cho chu·ªói
      ctx.globalAlpha = props.opacity;

      // 1. V·∫Ω v√≤ng h√†o quang (glow circles)
      if (props.glowOffset > 0) {
        const gradient = ctx.createRadialGradient(X, Y, bulbRadius, X, Y, glowRadius);
        // Gradient m√†u t·ª´ s√°ng tr·∫Øng (t√¢m) ra ngo√†i
        gradient.addColorStop(0, CGL.colorConvert.opacity(CGL.colorConvert.mixBlendColors(currentColor, '#fff', .3), .5));
        gradient.addColorStop(.25, CGL.colorConvert.opacity(currentColor, .6));
        gradient.addColorStop(.5, CGL.colorConvert.opacity(currentColor, .3));
        gradient.addColorStop(.75, CGL.colorConvert.opacity(currentColor, .125));
        gradient.addColorStop(1, CGL.colorConvert.opacity(currentColor, 0));
        ctx.fillStyle = gradient;    
        ctx.beginPath();
        ctx.arc(X, Y, glowRadius, 0, 2 * Math.PI);
        ctx.fill();
      }

      // 2. V·∫Ω b√≥ng ƒë√®n (bulbs)
      ctx.fillStyle = currentColor;
      ctx.beginPath();
      ctx.arc(X, Y, bulbRadius, 0, 2 * Math.PI);
      ctx.fill();
    }
  }

  function render() {
    updateScene();
    // V√≤ng l·∫∑p qua t·∫•t c·∫£ c√°c chu·ªói ƒë·ªÉ v·∫Ω
    chains.forEach(chain => renderChain(chain));
  }

  // H√†m xoay v√† animation
  function rotate() {
    rotationZ = (rotationZ - 1) % 360; // Xoay 1 ƒë·ªô m·ªói frame
    render();
    
    window.requestAnimationFrame(rotate);
  }

  // Kh·ªüi ƒë·ªông animation
  rotate();

  // X·ª≠ l√Ω s·ª± ki·ªán thay ƒë·ªïi k√≠ch th∆∞·ªõc c·ª≠a s·ªï
  window.addEventListener('resize', render);
  window.addEventListener('orientationchange', render);
  </script>
</body>
</html>
